type NFTMetadata = record {
    name: text;
    description: text;
    image: text;
    attributes: vec Attribute;
};

type Attribute = record {
    trait_type: text;
    value: text;
};

type Certificate = record {
    id: nat;
    registered: bool;
    metadata: opt NFTMetadata;
    owner: text;
    author: text;
    signature: opt text;
};

type Error = variant {
  NotFound: ErrorReason;
  PermissionDenied: ErrorReason;
  Validation: ErrorReason;
};

type ErrorReason = record {
    msg: text;
};

type Frame = record {
    id: nat;
    nft: opt NFT
};

type Tag = record {
    id: nat;
    short_id: text;
    is_certificate: bool;
    owner: text;
};

type NFT = record {
   id: text;
   contract_address: text;
   chain: text;
};

type VerifyResult = variant {
    Ok: variant {
        Certificate: Certificate;
        Frame: Frame;
    };
    Err: Error;
};

type UpdateResult = variant {
    Ok: text;
    Err: Error;
};

type GetTagResult = variant {
    Ok: Tag;
    Err: Error;
};

type GetCertificateResult = variant {
    Ok: Certificate;
    Err: Error;
};

type StoreArg = record {
    key: text;
    content_type: text;
    content_encoding: text;
    content: blob;
    sha256: opt blob
};

service : {
    "add_tag": (text, Tag) -> (UpdateResult);
    "get_certificate": (text) -> (GetCertificateResult) query;
    "get_tag": (text) -> (GetTagResult) query;
    "get_tags": () -> (vec Tag) query;
    "get_tags_owned_by": (text) -> (vec Tag) query;
    "is_admin": (principal) -> (bool) query;
    "save_certificate_with_media": (text, NFTMetadata, text, StoreArg) -> ();
    "set_key": (text, text) -> (UpdateResult);
    "register_certificate": (text, text) -> (UpdateResult);
    "verify_tag": (text) -> (VerifyResult);
};
