type NFTMetadata = record {
    name: text;
    description: text;
    image: text;
    attributes: vec Attribute;
};

type Attribute = record {
    trait_type: text;
    value: text;
};

type Certificate = record {
    id: nat;
    registered: bool;
    metadata: opt NFTMetadata;
    owner: text;
    author: text;
};

type Error = variant {
  NotFound: ErrorReason;
  PermissionDenied: ErrorReason;
  Validation: ErrorReason;
};

type ErrorReason = record {
    msg: text;
};

type Frame = record {
    id: nat;
    nft: opt NFT
};

type Tag = record {
    id: nat;
    short_id: text;
    is_certificate: bool;
    owner: text;
};

type NFT = record {
   id: text;
   contract_address: text;
   chain: text;
};

type VerifyResult = variant {
    Ok: variant {
        Certificate: Certificate;
        Frame: Frame;
    };
    Err: Error;
};

type UpdateResult = variant {
    Ok: text;
    Err: Error;
};

type GetTagResult = variant {
    Ok: Tag;
    Err: Error;
};

type GetStorageResult = variant {
    Ok: principal;
    Err: Error;
};

type GetCertificateResult = variant {
    Ok: Certificate;
    Err: Error;
};

type StoreArg = record {
    key: text;
    content_type: text;
    content_encoding: text;
    content: blob;
    sha256: opt blob
};

type HeaderField = record { text; text; };

type HttpRequest = record {
  method: text;
  url: text;
  headers: vec HeaderField;
  body: blob;
  certificate_version: opt nat16;
};

type HttpResponse = record {
  status_code: nat16;
  headers: vec HeaderField;
  body: blob;
  streaming_strategy: opt StreamingStrategy;
};

type StreamingCallbackToken = record {
  key: text;
  content_encoding: text;
  index: nat;
  sha256: opt blob;
};

type StreamingStrategy = variant {
  Callback: record {
    callback: func (StreamingCallbackToken) -> (opt StreamingCallbackHttpResponse) query;
    token: StreamingCallbackToken;
  };
};

type StreamingCallbackHttpResponse = record {
  body: blob;
  token: opt StreamingCallbackToken;
};

service : {
    "add_tag": (id: text, tag: Tag) -> (UpdateResult);
    "get_certificate": (tag_id: text) -> (GetCertificateResult) query;
    "get_storage_principal": (tag: text) -> (GetStorageResult) query;
    "get_tag": (tag_id: text) -> (GetTagResult) query;
    "get_tags": () -> (vec Tag) query;
    "get_tags_owned_by": (owner: text) -> (vec Tag) query;
    "http_request": (req: HttpRequest) -> (HttpResponse) query;
    "is_admin": (user: principal) -> (bool) query;
    "register_certificate": (id: text) -> (UpdateResult);
    "save_certificate": (tag_id: text, metadata: NFTMetadata) -> (UpdateResult);
    "set_key": (key: text, value: text) -> (UpdateResult);
    "upload_media": (tag_id: text, media: StoreArg) -> (UpdateResult);
    "verify_tag": (msg: text) -> (VerifyResult);
};
